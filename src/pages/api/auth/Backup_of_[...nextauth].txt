Backup os [...nextauth].ts

import NextAuth, { type NextAuthOptions } from "next-auth";
import GitHubProvider from "next-auth/providers/github";
import CredentialsProvider from "next-auth/providers/credentials";
import bcrypt from "bcryptjs";
import prisma from "@/lib/prisma";
import { PrismaAdapter } from "@next-auth/prisma-adapter";

export const authOptions: NextAuthOptions = {

    debug: true,

    adapter: PrismaAdapter(prisma),

    session: { strategy: "database" },

    providers: [
        GitHubProvider({
            clientId: process.env.GITHUB_ID as string,
            clientSecret: process.env.GITHUB_SECRET as string,
        }),

        CredentialsProvider({
            name: "credentials",
            credentials: {
                email: { label: "Email", type: "email" },
                password: { label: "Password", type: "password" },
            },

            async authorize(credentials) {
                if (!credentials?.email || !credentials.password) {
                    console.log("Email or password missing");
                    return null;
                }

                try {
                    const user = await prisma.user.findUnique({
                        where: { email: credentials.email.toLowerCase() }
                    })

                    if (!user) {
                        console.log("User not found, please sign up first");
                        return null;
                    }

                    const isValid = await bcrypt.compare(credentials.password, user.password as string);

                    if (!isValid) {
                        console.log("incorrect password");
                        return null;
                    }

                    return {
                        id: String(user.id),
                        name: user.name,
                        email: user.email,
                        role: user.role,
                        createdAt: user.createdAt,
                        updatedAt: user.updatedAt,
                    }

                } catch (error) {
                    console.error(`Error: ${error}`);
                    return null;
                }

            }
        })
    ],

    callbacks: {
        // Always return boolean from signIn
        async signIn({ user, account, profile }) {
            if (!user.email || !account) return false;

            console.log(`USER: ${user}`);
            console.log(`ACCOUNT: ${account}`);

            // Credentials sign-in → always allow
            if (account.provider === "credentials") {
                return true;
            }

            // OAuth sign-in → check for existing user
            const existingUser = await prisma.user.findUnique({
                where: { email: user.email },
                include: { accounts: true },
            });

            if (!existingUser) {
                // New OAuth user → allow NextAuth to create everything
                return true;
            }

            // Check if provider already linked
            const providerLinked = existingUser.accounts.some(
                (acc) => acc.provider === account.provider
            );

            if (!providerLinked) {
                // Manually link OAuth provider
                await prisma.account.create({
                    data: {
                        userId: existingUser.id,
                        provider: account.provider,
                        providerAccountId: account.providerAccountId!,
                    },
                });
            }

            // Mark email as verified for OAuth
            if (!existingUser.emailVerified) {
                await prisma.user.update({
                    where: { id: existingUser.id },
                    data: { emailVerified: new Date() },
                });
            }

            return true;

        },

        async jwt({ token, user, account }) {
            // When user logs in for first time in a session
            if (user) {
                token.id = (user as any).id;
            }
            if (account) {
                token.provider = account.provider;
            }
            return token;
        },

        async session({ session, token }) {
            if (session.user && token) {
                (session.user as any).id = token.id as string;
                (session.user as any).provider = token.provider as string | undefined;
            }
            return session;
        },
    },
};

export default NextAuth(authOptions); 







==========================================================================================================







import NextAuth from "next-auth";
import GitHubProvider from "next-auth/providers/github";
import CredentialsProvider from "next-auth/providers/credentials";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";

export const authOptions = ({
    debug: true,

    adapter: PrismaAdapter(prisma),

    session: {
        strategy: "database",
    },

    cookies: {
        sessionToken: {
            name: "next-auth.session-token",
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: false, // MUST be false on localhost
            },
        },
    },


    providers: [
        GitHubProvider({
            clientId: process.env.GITHUB_ID!,
            clientSecret: process.env.GITHUB_SECRET!,
        }),

        CredentialsProvider({
            name: "Credentials",
            credentials: {
                email: { label: "Email", type: "email" },
                password: { label: "Password", type: "password" },
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials.password) return null;

                const user = await prisma.user.findUnique({
                    where: { email: credentials.email.toLowerCase().trim() },
                });

                if (!user || !user.password) return null;

                const ok = await bcrypt.compare(
                    credentials.password,
                    user.password
                );

                if (!ok) return null;

                return {
                    id: user.id,
                    email: user.email,
                    name: user.name,
                };
            },
        }),
    ],

    callbacks: {
        async signIn({ user, account }) {
            // Credentials: ALWAYS allow, no DB work
            if (account?.provider === "credentials" || !account) {
                return true;
            }

            // OAuth only below
            if (!user?.email) return false;

            const existingUser = await prisma.user.findUnique({
                where: { email: user.email },
                include: { accounts: true },
            });

            if (!existingUser) return true;

            const linked = existingUser.accounts.some(
                (acc) => acc.provider === account.provider
            );

            if (!linked) {
                await prisma.account.create({
                    data: {
                        userId: existingUser.id,
                        provider: account.provider,
                        providerAccountId: account.providerAccountId!,
                    },
                });
            }

            return true;
        },

        async session({ session, user }) {
            // if (session.user && user) {
            //     session.user.id = user.id;
            //     session.user.role = user.role;
            // }
            console.log(`This is session form nextauth: ${session}`)
            return session;
        },
    },
});

export default NextAuth(authOptions);
